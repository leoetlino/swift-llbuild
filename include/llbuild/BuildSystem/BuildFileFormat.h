// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BUILDFILE_LLBUILD_BUILDSYSTEM_FORMAT_H_
#define FLATBUFFERS_GENERATED_BUILDFILE_LLBUILD_BUILDSYSTEM_FORMAT_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"

namespace llbuild {
namespace buildsystem {
namespace format {

struct Client;

struct Tool;

struct Target;

struct Node;

struct Command;

struct BuildFile;

struct Client FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERSION = 6,
    VT_PROPERTIES = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 0);
  }
  const flatbuffers::Vector<uint8_t> *properties() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PROPERTIES);
  }
  flexbuffers::Reference properties_flexbuffer_root() const {
    return flexbuffers::GetRoot(properties()->Data(), properties()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.EndTable();
  }
};

struct ClientBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Client::VT_NAME, name);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(Client::VT_VERSION, version, 0);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> properties) {
    fbb_.AddOffset(Client::VT_PROPERTIES, properties);
  }
  explicit ClientBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientBuilder &operator=(const ClientBuilder &);
  flatbuffers::Offset<Client> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Client>(end);
    fbb_.Required(o, Client::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Client> CreateClient(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> properties = 0) {
  ClientBuilder builder_(_fbb);
  builder_.add_properties(properties);
  builder_.add_version(version);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Client> CreateClientDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t version = 0,
    const std::vector<uint8_t> *properties = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto properties__ = properties ? _fbb.CreateVector<uint8_t>(*properties) : 0;
  return llbuild::buildsystem::format::CreateClient(
      _fbb,
      name__,
      version,
      properties__);
}

struct Tool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PROPERTIES = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *properties() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PROPERTIES);
  }
  flexbuffers::Reference properties_flexbuffer_root() const {
    return flexbuffers::GetRoot(properties()->Data(), properties()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.EndTable();
  }
};

struct ToolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tool::VT_NAME, name);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> properties) {
    fbb_.AddOffset(Tool::VT_PROPERTIES, properties);
  }
  explicit ToolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ToolBuilder &operator=(const ToolBuilder &);
  flatbuffers::Offset<Tool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tool>(end);
    fbb_.Required(o, Tool::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Tool> CreateTool(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> properties = 0) {
  ToolBuilder builder_(_fbb);
  builder_.add_properties(properties);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tool> CreateToolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *properties = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto properties__ = properties ? _fbb.CreateVector<uint8_t>(*properties) : 0;
  return llbuild::buildsystem::format::CreateTool(
      _fbb,
      name__,
      properties__);
}

struct Target FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_COMMANDS = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *commands() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COMMANDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfStrings(commands()) &&
           verifier.EndTable();
  }
};

struct TargetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Target::VT_NAME, name);
  }
  void add_commands(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> commands) {
    fbb_.AddOffset(Target::VT_COMMANDS, commands);
  }
  explicit TargetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TargetBuilder &operator=(const TargetBuilder &);
  flatbuffers::Offset<Target> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Target>(end);
    fbb_.Required(o, Target::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Target> CreateTarget(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> commands = 0) {
  TargetBuilder builder_(_fbb);
  builder_.add_commands(commands);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Target> CreateTargetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *commands = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto commands__ = commands ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*commands) : 0;
  return llbuild::buildsystem::format::CreateTarget(
      _fbb,
      name__,
      commands__);
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PROPERTIES = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *properties() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PROPERTIES);
  }
  flexbuffers::Reference properties_flexbuffer_root() const {
    return flexbuffers::GetRoot(properties()->Data(), properties()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Node::VT_NAME, name);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> properties) {
    fbb_.AddOffset(Node::VT_PROPERTIES, properties);
  }
  explicit NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeBuilder &operator=(const NodeBuilder &);
  flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Node>(end);
    fbb_.Required(o, Node::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> properties = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_properties(properties);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *properties = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto properties__ = properties ? _fbb.CreateVector<uint8_t>(*properties) : 0;
  return llbuild::buildsystem::format::CreateNode(
      _fbb,
      name__,
      properties__);
}

struct Command FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TOOL = 6,
    VT_INPUTS = 8,
    VT_OUTPUTS = 10,
    VT_DESCRIPTION = 12,
    VT_PROPERTIES = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *tool() const {
    return GetPointer<const flatbuffers::String *>(VT_TOOL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUTS);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::Vector<uint8_t> *properties() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PROPERTIES);
  }
  flexbuffers::Reference properties_flexbuffer_root() const {
    return flexbuffers::GetRoot(properties()->Data(), properties()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_TOOL) &&
           verifier.VerifyString(tool()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfStrings(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.EndTable();
  }
};

struct CommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Command::VT_NAME, name);
  }
  void add_tool(flatbuffers::Offset<flatbuffers::String> tool) {
    fbb_.AddOffset(Command::VT_TOOL, tool);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs) {
    fbb_.AddOffset(Command::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs) {
    fbb_.AddOffset(Command::VT_OUTPUTS, outputs);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Command::VT_DESCRIPTION, description);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> properties) {
    fbb_.AddOffset(Command::VT_PROPERTIES, properties);
  }
  explicit CommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommandBuilder &operator=(const CommandBuilder &);
  flatbuffers::Offset<Command> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Command>(end);
    fbb_.Required(o, Command::VT_NAME);
    fbb_.Required(o, Command::VT_TOOL);
    return o;
  }
};

inline flatbuffers::Offset<Command> CreateCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> tool = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> properties = 0) {
  CommandBuilder builder_(_fbb);
  builder_.add_properties(properties);
  builder_.add_description(description);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_tool(tool);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Command> CreateCommandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *tool = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *outputs = nullptr,
    const char *description = nullptr,
    const std::vector<uint8_t> *properties = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto tool__ = tool ? _fbb.CreateString(tool) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*outputs) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto properties__ = properties ? _fbb.CreateVector<uint8_t>(*properties) : 0;
  return llbuild::buildsystem::format::CreateCommand(
      _fbb,
      name__,
      tool__,
      inputs__,
      outputs__,
      description__,
      properties__);
}

struct BuildFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT = 4,
    VT_TOOLS = 6,
    VT_TARGETS = 8,
    VT_DEFAULT_ = 10,
    VT_NODES = 12,
    VT_COMMANDS = 14
  };
  const Client *client() const {
    return GetPointer<const Client *>(VT_CLIENT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Tool>> *tools() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tool>> *>(VT_TOOLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Target>> *targets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Target>> *>(VT_TARGETS);
  }
  const flatbuffers::String *default_() const {
    return GetPointer<const flatbuffers::String *>(VT_DEFAULT_);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Node>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Node>> *>(VT_NODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Command>> *commands() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Command>> *>(VT_COMMANDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CLIENT) &&
           verifier.VerifyTable(client()) &&
           VerifyOffset(verifier, VT_TOOLS) &&
           verifier.VerifyVector(tools()) &&
           verifier.VerifyVectorOfTables(tools()) &&
           VerifyOffset(verifier, VT_TARGETS) &&
           verifier.VerifyVector(targets()) &&
           verifier.VerifyVectorOfTables(targets()) &&
           VerifyOffset(verifier, VT_DEFAULT_) &&
           verifier.VerifyString(default_()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           verifier.EndTable();
  }
};

struct BuildFileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_client(flatbuffers::Offset<Client> client) {
    fbb_.AddOffset(BuildFile::VT_CLIENT, client);
  }
  void add_tools(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tool>>> tools) {
    fbb_.AddOffset(BuildFile::VT_TOOLS, tools);
  }
  void add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Target>>> targets) {
    fbb_.AddOffset(BuildFile::VT_TARGETS, targets);
  }
  void add_default_(flatbuffers::Offset<flatbuffers::String> default_) {
    fbb_.AddOffset(BuildFile::VT_DEFAULT_, default_);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Node>>> nodes) {
    fbb_.AddOffset(BuildFile::VT_NODES, nodes);
  }
  void add_commands(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Command>>> commands) {
    fbb_.AddOffset(BuildFile::VT_COMMANDS, commands);
  }
  explicit BuildFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuildFileBuilder &operator=(const BuildFileBuilder &);
  flatbuffers::Offset<BuildFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BuildFile>(end);
    fbb_.Required(o, BuildFile::VT_CLIENT);
    return o;
  }
};

inline flatbuffers::Offset<BuildFile> CreateBuildFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Client> client = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tool>>> tools = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Target>>> targets = 0,
    flatbuffers::Offset<flatbuffers::String> default_ = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Node>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Command>>> commands = 0) {
  BuildFileBuilder builder_(_fbb);
  builder_.add_commands(commands);
  builder_.add_nodes(nodes);
  builder_.add_default_(default_);
  builder_.add_targets(targets);
  builder_.add_tools(tools);
  builder_.add_client(client);
  return builder_.Finish();
}

inline flatbuffers::Offset<BuildFile> CreateBuildFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Client> client = 0,
    const std::vector<flatbuffers::Offset<Tool>> *tools = nullptr,
    const std::vector<flatbuffers::Offset<Target>> *targets = nullptr,
    const char *default_ = nullptr,
    const std::vector<flatbuffers::Offset<Node>> *nodes = nullptr,
    const std::vector<flatbuffers::Offset<Command>> *commands = nullptr) {
  auto tools__ = tools ? _fbb.CreateVector<flatbuffers::Offset<Tool>>(*tools) : 0;
  auto targets__ = targets ? _fbb.CreateVector<flatbuffers::Offset<Target>>(*targets) : 0;
  auto default___ = default_ ? _fbb.CreateString(default_) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<Node>>(*nodes) : 0;
  auto commands__ = commands ? _fbb.CreateVector<flatbuffers::Offset<Command>>(*commands) : 0;
  return llbuild::buildsystem::format::CreateBuildFile(
      _fbb,
      client,
      tools__,
      targets__,
      default___,
      nodes__,
      commands__);
}

inline const llbuild::buildsystem::format::BuildFile *GetBuildFile(const void *buf) {
  return flatbuffers::GetRoot<llbuild::buildsystem::format::BuildFile>(buf);
}

inline const llbuild::buildsystem::format::BuildFile *GetSizePrefixedBuildFile(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<llbuild::buildsystem::format::BuildFile>(buf);
}

inline bool VerifyBuildFileBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<llbuild::buildsystem::format::BuildFile>(nullptr);
}

inline bool VerifySizePrefixedBuildFileBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<llbuild::buildsystem::format::BuildFile>(nullptr);
}

inline void FinishBuildFileBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<llbuild::buildsystem::format::BuildFile> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBuildFileBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<llbuild::buildsystem::format::BuildFile> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace format
}  // namespace buildsystem
}  // namespace llbuild

#endif  // FLATBUFFERS_GENERATED_BUILDFILE_LLBUILD_BUILDSYSTEM_FORMAT_H_
